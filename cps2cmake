#!/usr/bin/env python

import argparse
import cps
import sys

block_header = """
# Generated by cps2cmake
# https://github.com/mwoehlke/pycps

if(CMAKE_MAJOR_VERSION LESS 3)
  message(FATAL_ERROR "CMake >= 3.0 required")
endif()
cmake_policy(PUSH)
cmake_policy(VERSION 3.0)
set(CMAKE_IMPORT_FILE_VERSION 1)
"""

block_check_targets = """
set(_targetsDefined)
set(_targetsNotDefined)

foreach(_expectedTarget ${_expectedTargets})
  if(NOT TARGET ${_expectedTarget})
    list(APPEND _targetsNotDefined ${_expectedTarget})
  endif()
  if(TARGET ${_expectedTarget})
    list(APPEND _targetsDefined ${_expectedTarget})
  endif()
endforeach()
if("${_targetsDefined}" STREQUAL "${_expectedTargets}")
  set(CMAKE_IMPORT_FILE_VERSION)
  cmake_policy(POP)
  return()
endif()
if(NOT "${_targetsDefined}" STREQUAL "")
  message(FATAL_ERROR "Some (but not all) targets in this export set were already defined.\\nTargets Defined: ${_targetsDefined}\\nTargets not yet defined: ${_targetsNotDefined}\\n")
endif()
unset(_targetsDefined)
unset(_targetsNotDefined)
unset(_expectedTargets)
"""

block_get_prefix = """
get_filename_component(_IMPORT_PREFIX "${CMAKE_CURRENT_LIST_FILE}" PATH)
get_filename_component(_IMPORT_PREFIX "${_IMPORT_PREFIX}" PATH)
get_filename_component(_IMPORT_PREFIX "${_IMPORT_PREFIX}" PATH)
get_filename_component(_IMPORT_PREFIX "${_IMPORT_PREFIX}" PATH)

if(_IMPORT_PREFIX STREQUAL "/")
  set(_IMPORT_PREFIX)
endif()
"""

block_footer = """
unset(_IMPORT_PREFIX)
unset(CMAKE_IMPORT_FILE_VERSION)
cmake_policy(POP)
"""

block_check_version = """
if(PACKAGE_VERSION VERSION_LESS PACKAGE_FIND_VERSION)
  set(PACKAGE_VERSION_COMPATIBLE FALSE)
elseif(PACKAGE_VERSION VERSION_LESS COMPAT_VERSION)
  set(PACKAGE_VERSION_COMPATIBLE FALSE)
else()
  set(PACKAGE_VERSION_COMPATIBLE TRUE)
  if(PACKAGE_VERSION STREQUAL PACKAGE_FIND_VERSION)
    set(PACKAGE_VERSION_EXACT TRUE)
  endif()
endif()

unset(PACKAGE_COMPAT_VERSION)
"""

library_types = {
    'dylib': 'SHARED',
    'archive': 'STATIC',
    'module': 'MODULE',
    'interface': 'INTERFACE'
}

cpp11_features = {'cxx_decltype'}
cpp14_features = {'cxx_decltype_auto'}.union(cpp11_features)
feature_map = {
    'c++11': cpp11_features,
    'c++14': cpp14_features,
}

#------------------------------------------------------------------------------
def cmake_qualified_component_name(package, component_name):
    return '::'.join((package.name, component_name))

#------------------------------------------------------------------------------
def cmake_qualified_component_names(package):
    fixup = lambda c: cmake_qualified_component_name(package, c)
    return map(fixup, package.components)

#------------------------------------------------------------------------------
def fixup_path(path):
    if path.startswith('@prefix@'):
        return '${_IMPORT_PREFIX}' + path[8:]

    return path

#------------------------------------------------------------------------------
def canonical_component_name(component, package):
    if component.startswith(':'):
        return ':'.join((package.name, component[1:]))

    return component

#------------------------------------------------------------------------------
def cmake_canonical_component_name(package, component):
    component = canonical_component_name(component, package)
    return '::'.join(component.split('@')[0].split(':'))

#------------------------------------------------------------------------------
def print_target_rules(package, component_name, component):
    # TODO java targets
    kind = component.kind.lower()
    if kind in library_types:
        print('add_library(%s %s IMPORTED)' %
              (component_name, library_types[kind]))
        print('set_target_properties(%s PROPERTIES' % component_name)

        if component.link_location is not None:
            print('  IMPORTED_LOCATION "%s"' %
                  fixup_path(component.link_location))

        includes = component.includes[None]
        if len(includes):
            includes = map(fixup_path, includes)
            print('  INTERFACE_INCLUDE_DIRECTORIES "%s"' % ';'.join(includes))

        if len(component.requires) or len(component.link_requires):
            fixup = lambda dep: cmake_canonical_component_name(package, dep)
            cdeps = map(fixup, component.requires)
            ldeps = map(fixup, component.link_requires)
            deps = cdeps + map(lambda d: '$<LINK_ONLY:%s>' % d, ldeps)
            print('  INTERFACE_LINK_LIBRARIES %s' % ';'.join(deps))

        features = set()
        for feature in component.compile_features:
            features = features.union(feature_map.get(feature, set()))
        if len(features):
            print('  INTERFACE_COMPILE_FEATURES "%s"' % ';'.join(features))

        print(')')

    elif kind == 'exe':
        print('add_executable(%s IMPORTED)' % component_name)
        print('set_target_properties(%s PROPERTIES' % component_name)
        print('  IMPORTED_LOCATION "%s"' % fixup_path(component.location))
        print(')')

    elif kind == 'jar':
        print('add_library(%s STATIC IMPORTED)' % component_name)
        print('set_target_properties(%s PROPERTIES' % component_name)
        print('  IMPORTED_LOCATION "%s"' % fixup_path(component.location))
        print('  JAR_FILE "%s"' % fixup_path(component.location))
        print(')')

#------------------------------------------------------------------------------
def print_convenience_rules(package):
    fixup = lambda c: cmake_canonical_component_name(package, c)
    libs = map(fixup, package.default_components)
    print('set(%s_LIBRARIES "%s")' % (package.name, ';'.join(libs)))
    print('set(%s_INCLUDE_DIRS "")' % package.name)
    print('')

#------------------------------------------------------------------------------
def print_cmake_extensions(package):
    for item in package.extensions.get('X-CMake-Includes', []):
        print('include(%s)' % item)
    for item in package.extensions.get('X-CMake-Variables', {}).iteritems():
        print('set(%s "%s")' % item)

#------------------------------------------------------------------------------
def print_targets_config(package):
    targets = cmake_qualified_component_names(package)

    print(block_header)
    print('set(_expectedTargets %s)' % ' '.join(targets))
    print(block_check_targets)
    print(block_get_prefix) # TODO account for install subdirectory

    if package.version is not None:
        print('set(%s_VERSION "%s")' % (package.name, package.version))
        print('')

    for component_name, component in package.components.iteritems():
        component_name = cmake_qualified_component_name(package, component_name)
        print_target_rules(package, component_name, component)
        print('')

    print_convenience_rules(package)
    print_cmake_extensions(package)

    print(block_footer)

#------------------------------------------------------------------------------
def print_version_check(package):
    if package.version is not None:
        print('set(PACKAGE_VERSION "%s")' % package.version)
        print('set(PACKAGE_COMPAT_VERSION "%s")' % package.compat_version)
        print(block_check_version)

    # TODO arch check (32-bit vs. 64-bit)

#------------------------------------------------------------------------------
def main(args):
    parser = argparse.ArgumentParser()
    parser.add_argument('input', metavar='CPS_FILE', type=str,
                        help='Input CPS file')
    parser.add_argument('--version-check',
                        dest='version_check', action='store_true',
                        help='Emit version check instead of targets')
    args = parser.parse_args(args)

    package = cps.read(args.input, canonicalize=False)

    if args.version_check:
        print_version_check(package)
    else:
        print_targets_config(package)

#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

if __name__ == "__main__":
    main(sys.argv[1:])
