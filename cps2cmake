#!/usr/bin/env python

import cps
import sys

block_header = """
# Generated by cps2cmake

if(CMAKE_MAJOR_VERSION LESS 3)
  message(FATAL_ERROR "CMake >= 3.0 required")
endif()
cmake_policy(PUSH)
cmake_policy(VERSION 3.0)
set(CMAKE_IMPORT_FILE_VERSION 1)
"""

block_check_targets = """
set(_targetsDefined)
set(_targetsNotDefined)

foreach(_expectedTarget ${_expectedTargets})
  if(NOT TARGET ${_expectedTarget})
    list(APPEND _targetsNotDefined ${_expectedTarget})
  endif()
  if(TARGET ${_expectedTarget})
    list(APPEND _targetsDefined ${_expectedTarget})
  endif()
endforeach()
if("${_targetsDefined}" STREQUAL "${_expectedTargets}")
  set(CMAKE_IMPORT_FILE_VERSION)
  cmake_policy(POP)
  return()
endif()
if(NOT "${_targetsDefined}" STREQUAL "")
  message(FATAL_ERROR "Some (but not all) targets in this export set were already defined.\\nTargets Defined: ${_targetsDefined}\\nTargets not yet defined: ${_targetsNotDefined}\\n")
endif()
unset(_targetsDefined)
unset(_targetsNotDefined)
unset(_expectedTargets)
"""

block_get_prefix = """
get_filename_component(_IMPORT_PREFIX "${CMAKE_CURRENT_LIST_FILE}" PATH)
get_filename_component(_IMPORT_PREFIX "${_IMPORT_PREFIX}" PATH)
get_filename_component(_IMPORT_PREFIX "${_IMPORT_PREFIX}" PATH)
get_filename_component(_IMPORT_PREFIX "${_IMPORT_PREFIX}" PATH)

if(_IMPORT_PREFIX STREQUAL "/")
  set(_IMPORT_PREFIX)
endif()
"""

block_footer = """
unset(_IMPORT_PREFIX)
unset(CMAKE_IMPORT_FILE_VERSION)
cmake_policy(POP)
"""

library_types = {
    'dylib': 'SHARED',
    'archive': 'STATIC',
    'module': 'MODULE',
    'interface': 'INTERFACE'
}

#------------------------------------------------------------------------------
def qualified_component_name(package, component_name):
    return '::'.join((package.name, component_name))

#------------------------------------------------------------------------------
def qualified_component_names(package):
    result = []
    for component_name in package.components:
        result.append(qualified_component_name(package, component_name))

    return result

#------------------------------------------------------------------------------
def fixup_path(path):
    if path.startswith('@prefix@'):
        return '${_IMPORT_PREFIX}' + path[8:]

    return path

#------------------------------------------------------------------------------
def print_target_rules(component_name, component):
    kind = component.kind.lower()
    if kind in library_types:
        print('add_library(%s %s IMPORTED)' %
              (component_name, library_types[kind]))
        print('set_target_properties(%s PROPERTIES' % component_name)

        if component.link_location is not None:
            print('  IMPORTED_LOCATION "%s"' %
                  fixup_path(component.link_location))

        includes = component.includes[None]
        if len(includes):
            includes = map(fixup_path, includes)
            print('  INTERFACE_INCLUDE_DIRECTORIES "%s"' % ';'.join(includes))

        # TODO requires
        print(')')

#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

package = cps.read(sys.argv[1], canonicalize=False)
targets = qualified_component_names(package)

print(block_header)
print('set(_expectedTargets %s)' % ' '.join(targets))
print(block_check_targets)
print(block_get_prefix) # TODO account for install subdirectory

for component_name, component in package.components.iteritems():
    component_name = qualified_component_name(package, component_name)
    print_target_rules(component_name, component)
    print('')

print(block_footer)
